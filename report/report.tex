\documentclass[a4paper,12pt]{article}
\usepackage[noabs]{HaotianReport}
\usepackage{matlab-prettifier} % for matlab code

\title{第二次作业}
\author{刘昊天}
\authorinfo{电博181班, 2018310648}
\runninghead{高等电力网络分析}
\studytime{2018年12月}

\newcommand{\vect}[1]{\boldsymbol{#1}}

\begin{document}
    \maketitle
    %\newpage
    \section{牛顿-拉斐逊方法求解潮流方程}
    \subsection{题目1 算例解读}
    \paragraph{题目描述} 通过case30.m中的算例基本数据，明确各节点类型，分别说明在直角坐标和极坐标情况下的已知量和待求量都有哪些，形式上需要几个等式方程。

    查询MATPOWER手册【TODO】可知，结构体中的bus属性对应的bus\_type区分了节点的类型，其中PQ节点值为1，PV节点值为2，参考节点值为3，孤立节点值为4。因此，可以通过以下程序统计各类型节点数量：

    \begin{lstlisting}[style=Matlab-editor,basicstyle=\mlttfamily]
mpc = case30();
%% Watch case30
n_pq = sum(mpc.bus(:, BUS_TYPE) == 1);
n_pv = sum(mpc.bus(:, BUS_TYPE) == 2);
n_ref = sum(mpc.bus(:, BUS_TYPE) == 3);
    \end{lstlisting}
    得到结果，
    \begin{lstlisting}
Bus Type: PQ: 24, PV: 5, REF: 1
    \end{lstlisting}

    对于一个$n=N-1$节点的系统来说，设其中共有$r$个PV节点，则共有$n-r$个PQ节点。在本题中，$n=29,r=5$。

    在直角坐标的情况下，待求变量共$2n$个，用
    $$x=[\vect{e}^T \quad \vect{f}]^T=[e_1,e_2,...,e_n,f_1,f_2,...,f_n]^T$$ 表示，潮流方程为\cref{eq:pfzj}，共$2n$个等式。本题中，共58个待求变量（包括29个电压实部与29个电压虚部），58个等式。
    \begin{equation}
      \label{eq:pfzj}
      \begin{cases}
        \Delta P_i = P^{SP}_i-(e_a a_i+ f_i b_i) = 0 \quad i=1,2,...,n\\
        \Delta Q_i = Q^{SP}_i - (f_i a_i - e_i b_i) = 0 \quad i = 1,2,...,n-r\\
        \Delta V_i^2 = (V_i^{SP})^2-(e_i^2+f_i^2)=0 \quad i=n-r+1,...,n
      \end{cases}
    \end{equation}

    在直角坐标的情况下，待求变量共$2n-r$个，用
    $$x=[\vect{\theta}^T \quad \vect{V}]^T=[\theta_1,\theta_2,...,\theta_n,V_1,V_2,...,V_{n-r}]^T$$ 表示，潮流方程为\cref{eq:pfjzb}，共$2n-r$个等式，其中$N_i$表示与节点i直接相连的节点编号集合。本题中，共53个待求变量（包括29个相角与24个电压幅值），53个等式。
    \begin{equation}
      \label{eq:pfjzb}
      \begin{cases}
        \Delta P_i = P^{SP}_i - V_i \sum_{j\in N_i}V_j(G_{ij}\cos \theta_{ij}+B_{ij}\sin \theta_{ij}) = 0 \quad i=1,2,...,n\\
        \Delta Q_i = Q^{SP}_i - V_i \sum_{j\in N_i}V_j(G_{ij}\sin \theta_{ij}-B_{ij}\cos \theta_{ij}) = 0 \quad i = 1,2,...,n-r\\
      \end{cases}
    \end{equation}

    \subsection{题目2 程序解释}
    \paragraph{题目描述} 仔细阅读runpf函数及matpower手册，解释matpower在求解潮流方程时各步骤的原理。尝试使用N-R方法（newtonpf）进行潮流方程的求解。注意其对节点类型、边界条件的处理方法，分析并探讨N-R方法算法流程、雅克比矩阵、PQ失配量的处理方法，并学习其中的编程技巧。

    经过对runpf函数的研读，发现MATPOWER在计算电力系统潮流时考虑了各种情况，虽然程序结构比较复杂，但总体上可以分为潮流方程构造与潮流方程求解两部分，并进行了一定的迭代。下面从这两方面依次说明，由于本题的重点在于潮流方程的求解，因此相关部分将重点说明。

    \subsubsection{潮流方程构造}
    \begin{enumerate}
      \item 处理算法的配置。runpf中考虑的配置包括：直流/交流潮流、无功越线情况处理、记录及保存计算结果等。
      \item 无功越线情况处理。如果开启了无功越线，则runpf程序将对潮流方程多次求解。对于某一次求解结果，如果有PV节点的无功输出超出其限制范围，则将该节点转换为PQ节点（其中无功输出为无功限值），再继续下一次求解，直到没有无功越线的情况出现。根据设置，在出现多个越线节点时，可以选择其中越线最大的节点进行处理，也可以全部进行处理。关键代码如下：
      \begin{lstlisting}[style=Matlab-editor,basicstyle=\mlttfamily]
while (repeat)
      %% function for computing V dependent complex bus power injections
      %% (generation - load)
      Sbus = @(Vm)makeSbus(baseMVA, bus, gen, mpopt, Vm);
      [V, success, iterations] = newtonpf(Ybus, Sbus, V0, ref, pv, pq, mpopt);
      its = its + iterations;
      %% update data matrices with solution
      [bus, gen, branch] = pfsoln(baseMVA, bus, gen, branch, Ybus, Yf, Yt, V, ref, pv, pq, mpopt);
      if qlim             %% enforce generator Q limits
          %% find gens with violated Q constraints
          mx = find( gen(:, GEN_STATUS) > 0 ...
                  & gen(:, QG) > gen(:, QMAX) + mpopt.opf.violation );
          mn = find( gen(:, GEN_STATUS) > 0 ...
                  & gen(:, QG) < gen(:, QMIN) - mpopt.opf.violation );

          if ~isempty(mx) || ~isempty(mn)  %% we have some Q limit violations
              %% 检查系统的收敛性
              infeas = union(mx', mn')';
              remaining = find( gen(:, GEN_STATUS) > 0 & ...
                              ( bus(gen(:, GEN_BUS), BUS_TYPE) == PV | ...
                                bus(gen(:, GEN_BUS), BUS_TYPE) == REF ));
              if length(infeas) == length(remaining) && all(infeas == remaining) && ...
                      (isempty(mx) || isempty(mn))
                  %% 若所有剩余的PV节点与REF节点都同时越上限或下限，则该系统无解
                  success = 0;
                  break;
              end

              %% 如果设置，每次只处理一个节点
              if qlim == 2    %% 选择越线幅度最大的节点
                  [junk, k] = max([gen(mx, QG) - gen(mx, QMAX);
                                   gen(mn, QMIN) - gen(mn, QG)]);
                  if k > length(mx)
                      mn = mn(k-length(mx));
                      mx = [];
                  else
                      mx = mx(k);
                      mn = [];
                  end
              end

              %% save corresponding limit values
              fixedQg(mx) = gen(mx, QMAX);
              fixedQg(mn) = gen(mn, QMIN);
              mx = [mx;mn];

              %% convert to PQ bus
              %% 关闭发动机并在节点上引入等效的PQ负荷
              gen(mx, QG) = fixedQg(mx);      %% set Qg to binding limit
              gen(mx, GEN_STATUS) = 0;        %% temporarily turn off gen,
              for i = 1:length(mx)            %% (one at a time, since
                  bi = gen(mx(i), GEN_BUS);   %%  they may be at same bus)
                  bus(bi, [PD,QD]) = ...      %% adjust load accordingly,
                      bus(bi, [PD,QD]) - gen(mx(i), [PG,QG]);
              end
              if length(ref) > 1 && any(bus(gen(mx, GEN_BUS), BUS_TYPE) == REF)
                  %% 无法处理多松弛节点系统的松弛节点无功越线问题
                  error('runpf: Sorry, MATPOWER cannot enforce Q limits for slack buses in systems with multiple slacks.');
              end
              bus(gen(mx, GEN_BUS), BUS_TYPE) = PQ;   %% 调整节点类型

              %% update bus index lists of each type of bus
              ref_temp = ref;
              [ref, pv, pq] = bustypes(bus, gen);
              %% previous line can modify lists to select new REF bus
              %% if there was none, so we should update bus with these
              %% just to keep them consistent
              if ref ~= ref_temp
                  bus(ref, BUS_TYPE) = REF;
                  bus( pv, BUS_TYPE) = PV;
                  %% 设置新的参考（松弛）节点
              end
              limited = [limited; mx];
          else
              repeat = 0; %% 停止迭代
          end
      else
          repeat = 0; %% 停止迭代
      end
  end
      \end{lstlisting}
    \end{enumerate}
    \subsubsection{潮流方程求解}


    \section{分布因子与矫正控制}
    \subsection{题目1 分布因子计算}
    \paragraph{题目描述} 试用课本上学习的方法计算发电机输出功率转移分布因子，并与makePTDF函数的计算结果进行比对。

    \subsection{题目2 边界条件变化估算}
    \paragraph{题目描述} 利用分布因子方法估算潮流方程边界条件发生变化时的各线路潮流分布情况，并与在调整后边界条件下的潮流计算结果进行对比，探讨其中的差别与产生的原因。请根据以下场景进行计算：
    \subsubsection{场景1} 当位于2号节点的发电机有功出力减小0.1、1与10时。
    \subsubsection{场景2} 当位于2号节点的发电机有功出力减小0.1、1与10且位于13号节点的发电机有功出力相应增加0.1、1与10以使系统总调整量为0时。

    \subsection{题目3 矫正控制策略}
    \paragraph{题目描述} 利用分布因子方法计算为达到所期望的控制效果所需的矫正控制策略，并与在调整后边界条件下的潮流计算结果进行对比，探讨两者的差别与产生的原因。请根据以下场景进行计算：
    \subsubsection{场景1} 只调节位于27号节点的发电机的有功出力，其他机组有功出力不变，以使线路27-28上的有功功率降低0.1。
    \subsubsection{场景2} 请设计一种方案，选取一对节点并同时调节节点上发电机对的有功出力，以使线路27-28上的有功功率降低0.1。

    \bibliography{report}
    \bibliographystyle{ieeetr}
    \appendix
    \section{程序清单}
      \lstinputlisting[style=Matlab-editor,basicstyle=\mlttfamily,label=lst:hwtask,caption={全部作业任务}]{../hwtask.m}
    \label{applastpage}
\iffalse
\begin{itemize}[noitemsep,topsep=0pt]
%no white space
\end{itemize}
\begin{enumerate}[label=\Roman{*}.,noitemsep,topsep=0pt]
%use upper case roman
\end{enumerate}
\begin{multicols}{2}
%two columns
\end{multicols}
\fi
\end{document}
